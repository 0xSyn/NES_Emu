<?xml version="1.0" ?><!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Talk:Calculate CRC32</title>
<meta content="width=display-width" name="viewport"/>
<link href="w.css" rel="stylesheet" type="text/css"/>
<script src="w.js" type="text/javascript"/>
</head><body><h1>Talk:Calculate CRC32</h1><div class="article">
<h2><span class="mw-headline" id="Checksums.2Fhashes_article.3F">Checksums/hashes article?</span></h2>
<p>Just putting this here temporarily, until we can write an article on checksums.
</p>
<blockquote>&quot;&lt;Myria&gt; what would be a good checksum algorithm to use on 6502?  a literal check&quot;sum&quot; would not work, because of the nature of the data being checksummed.&quot;
<p>I'm working on this exact problem for multi-line serial transfers using controller ports and the expansion I/O port.  That link ( <a class="external free" href="http://6502.org/source/integers/crc-more.html" rel="nofollow">http://6502.org/source/integers/crc-more.html</a> ) is to a nice site.
</p><p><a class="external free" href="http://forums.nesdev.com/viewtopic.php?f=2&amp;t=13225" rel="nofollow">http://forums.nesdev.com/viewtopic.php?f=2&amp;t=13225</a>  I had a post specific to parity.  I plan on creating a separate topic on the Wiki or Forums with references for good non-parity methods of error-checking on the NES.
</p><p>ADC8 is one of the simplest.  You simply use ADC $xxxx,X on a sliding position in a 256-byte array for each page of the file/memory to checksum.  This is similar to ADD8 but high bit of last result is added to lowest bit of next sum in the series.
</p><p>XOR8 is stupidly universal and easy to implement.  Just use EOR $xxxx,X instead of ADC $xxxx,X.  As an added bonus, you can use the associative property as shown here:   <a class="external free" href="http://forums.nesdev.com/viewtopic.php?f=2&amp;t=13225#p154962" rel="nofollow">http://forums.nesdev.com/viewtopic.php?f=2&amp;t=13225#p154962</a>
</p>
To create a position-detecting hash, you keep doing something like XOR8 as normal, and then you keep a separate sum that adds the checksum in addition to just the current data byte being verified.  You'd have something like &quot;P=P XOR Byte(X):  Q=Q + P&quot; in BASIC.  Because P <i>at that time</i> varies, if bytes are swapped or missing or inserted, it changes the final value for Q.  All that matters is that the position changes the value that you're combining with Q.  P could even be Byte(X)+X.</blockquote>
<p><a href="User_Alphamule.xhtml" title="User:Alphamule">alphamule</a> (<s>talk</s>) 01:48, 5 October 2015 (MDT)
</p>
<!-- 
NewPP limit report
CPU time usage: 0.027 seconds
Real time usage: 0.030 seconds
Preprocessor visited node count: 2/1000000
Preprocessor generated node count: 8/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key nesdev_wiki-mw1_:pcache:idhash:1595-1!*!0!*!*!*!* and timestamp 20160214025930 and revision id 11951
 -->
</div></body></html>