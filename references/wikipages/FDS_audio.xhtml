<?xml version="1.0" ?><!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns="http://www.w3.org/1999/xhtml"><head><title>FDS audio</title>
<meta content="width=display-width" name="viewport"/>
<link href="w.css" rel="stylesheet" type="text/css"/>
<script src="w.js" type="text/javascript"/>
</head><body><h1>FDS audio</h1><div class="article">
<p>The <b>Famicom Disk System audio</b> is an audio channel generated by the 2C33 chip on the <a class="mw-redirect" href="Family_Computer_Disk_System.xhtml" title="Famicom Disk System">Famicom Disk System</a>'s RAM card and output through the Famicom cart edge connector's expansion audio pins.
</p><p>This channel rapidly repeats a <a class="extiw" href="http://en.wikipedia.org/wiki/wavetable_synthesis" title="wikipedia:wavetable synthesis">wavetable</a> set up by the CPU in a manner similar to channel 3 of the Game Boy but with more sophisticated modulation. By changing the waveform, the program can have it simulate many different instruments, such as in the musical game Otocky.
</p>
<div class="toc" id="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Registers"><span class="tocnumber">1</span> <span class="toctext">Registers</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Master_I.2FO_enable_.28.244023.29"><span class="tocnumber">1.1</span> <span class="toctext">Master I/O enable ($4023)</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Wavetable_RAM_.28.244040-.24407F.29"><span class="tocnumber">1.2</span> <span class="toctext">Wavetable RAM ($4040-$407F)</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Volume_envelope_.28.244080.29"><span class="tocnumber">1.3</span> <span class="toctext">Volume envelope ($4080)</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Frequency_low_.28.244082.29"><span class="tocnumber">1.4</span> <span class="toctext">Frequency low ($4082)</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Frequency_high_.28.244083.29"><span class="tocnumber">1.5</span> <span class="toctext">Frequency high ($4083)</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Mod_envelope_.28.244084.29"><span class="tocnumber">1.6</span> <span class="toctext">Mod envelope ($4084)</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Mod_counter_.28.244085.29"><span class="tocnumber">1.7</span> <span class="toctext">Mod counter ($4085)</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Mod_frequency_low_.28.244086.29"><span class="tocnumber">1.8</span> <span class="toctext">Mod frequency low ($4086)</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Mod_frequency_high_.28.244087.29"><span class="tocnumber">1.9</span> <span class="toctext">Mod frequency high ($4087)</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Mod_table_write_.28.244088.29"><span class="tocnumber">1.10</span> <span class="toctext">Mod table write ($4088)</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Wave_write_.2F_master_volume_.28.244089.29"><span class="tocnumber">1.11</span> <span class="toctext">Wave write / master volume ($4089)</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Envelope_speed_.28.24408A.29"><span class="tocnumber">1.12</span> <span class="toctext">Envelope speed ($408A)</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Volume_gain_.28.244090.29"><span class="tocnumber">1.13</span> <span class="toctext">Volume gain ($4090)</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Mod_gain_.28.244092.29"><span class="tocnumber">1.14</span> <span class="toctext">Mod gain ($4092)</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-16"><a href="#Frequency_calculation_and_timing"><span class="tocnumber">2</span> <span class="toctext">Frequency calculation and timing</span></a>
<ul>
<li class="toclevel-2 tocsection-17"><a href="#Envelopes"><span class="tocnumber">2.1</span> <span class="toctext">Envelopes</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Wavetables"><span class="tocnumber">2.2</span> <span class="toctext">Wavetables</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="#Unit_tick"><span class="tocnumber">3</span> <span class="toctext">Unit tick</span></a>
<ul>
<li class="toclevel-2 tocsection-20"><a href="#Envelopes_2"><span class="tocnumber">3.1</span> <span class="toctext">Envelopes</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#Modulation_unit"><span class="tocnumber">3.2</span> <span class="toctext">Modulation unit</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="#Wave_output_unit"><span class="tocnumber">3.3</span> <span class="toctext">Wave output unit</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-23"><a href="#Mixing"><span class="tocnumber">4</span> <span class="toctext">Mixing</span></a></li>
<li class="toclevel-1 tocsection-24"><a href="#References"><span class="tocnumber">5</span> <span class="toctext">References</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Registers">Registers</span></h2>
<h3><span class="mw-headline" id="Master_I.2FO_enable_.28.244023.29">Master I/O enable ($4023)</span></h3>
<p>This register must be written to with bit 1 set for the sound registers to function. The FDS bios initializes this by writing $00 followed by $83 to it.
</p>
<pre>7  bit  0
---------
xxxx xxSD
       ||
       |+- Enable disk I/O registers
       +-- Enable sound I/O registers
</pre>
<h3><span class="mw-headline" id="Wavetable_RAM_.28.244040-.24407F.29">Wavetable RAM ($4040-$407F)</span></h3>
<p>The 64-step waveform to be fed to the DAC. Each step consists of an unsigned sample value in the range [0, 63]. This can always be read by the CPU. However, it cannot be modified unless it is write-enabled, and it cannot be write-enabled while the sound is being played. (See also $4089 below.)
</p>
<pre>7  bit  0  (read/write)
---- ----
OOSS SSSS
|||| ||||
||++-++++- Sample
++-------- Returns 01 on read, likely from open bus
</pre>
<h3><span class="mw-headline" id="Volume_envelope_.28.244080.29">Volume envelope ($4080)</span></h3>
<p>The envelope speed is set by this register whether or not the envelope is enabled by the high bit,
but the current volume is set only if the high bit is set.
</p><p>The volume gain can range from 0 to 63; however, volume values above 32 are clamped to 32 before output.
</p><p>Writing to this register immediately resets the clock timer that ticks the volume envelope (delaying the next tick slightly).
</p>
<pre>7  bit  0  (write; read through $4090)
---- ----
MDVV VVVV
|||| ||||
||++-++++- (M=0) Volume envelope speed
||         (M=1) Volume gain and envelope speed.
|+-------- Volume change direction (0: decrease; 1: increase)
+--------- Volume envelope mode (0: on; 1: off)
</pre>
<h3><span class="mw-headline" id="Frequency_low_.28.244082.29">Frequency low ($4082)</span></h3>
<pre>7  bit  0  (write)
---- ----
FFFF FFFF
|||| ||||
++++-++++- Bits 0-7 of frequency
</pre>
<h3><span class="mw-headline" id="Frequency_high_.28.244083.29">Frequency high ($4083)</span></h3>
<p>The high bit of this register halts the waveform and resets its phase to 0.
Note that if halted it will output the constant value at $4040, and
writes to the volume register $4080 or master volume $4089 will affect the output.
The envelopes are not ticked while the waveform is halted.
</p><p>Bit 6 halts just the envelopes without halting the waveform, and also
resets both of their timers.
</p>
<pre>7  bit  0  (write)
---- ----
MExx FFFF
||   ||||
||   ++++- Bits 8-11 of frequency
|+-------- Disable volume and sweep envelopes (but not modulation)
+--------- Halt waveform and reset phase to 0, disable envelopes
</pre>
<h3><span class="mw-headline" id="Mod_envelope_.28.244084.29">Mod envelope ($4084)</span></h3>
<p>The envelope speed is set by this register whether or not the envelope is enabled by the high bit,
but the current mod gain is set only if the high bit is set.
</p><p>Writing to this register immediately resets the clock timer that ticks the modulator envelope (delaying the next tick slightly).
</p>
<pre>7  bit  0  (write; read through $4092)
---- ----
MDSS SSSS
|||| ||||
||++-++++- (M=0) Mod envelope speed
||         (M=1) Mod gain and envelope speed.
|+-------- Mod envelope direction (0: decrease; 1: increase)
+--------- Mod envelope mode (0: on; 1: off)
</pre>
<h3><span class="mw-headline" id="Mod_counter_.28.244085.29">Mod counter ($4085)</span></h3>
<p>This directly sets the 7-bit signed modulator counter that is otherwise controlled by the mod unit.
</p><p>Because the current playback position of the modulator unit is generally hard to predict while active,
it is bad practice to write $4085 unless the mod unit is disabled via $4087,
because it will generally result in a detuned note.
Bio Miracle Bokutte Upa does this, and it requires cycle-accurate timing to emulate correctly.
Some emulators incorrectly treat $4085 as a phase-reset for the mod table, which
will obviate this timing issue.
</p><p>It is generally good practice to write 0 to $4085 to reset the counter after
writing the mod table via $4088.
</p>
<pre>7  bit  0  (write)
---- ----
xBBB BBBB
 ||| ||||
 +++-++++- Mod counter (7-bit signed; minimum $40; maximum $3F)
</pre>
<h3><span class="mw-headline" id="Mod_frequency_low_.28.244086.29">Mod frequency low ($4086)</span></h3>
<p>If the 12-bit frequency is set to 0, modulation is disabled.
</p>
<pre>7  bit  0  (write)
---- ----
FFFF FFFF
|||| ||||
++++-++++- Bits 0-7 of modulation unit frequency
</pre>
<h3><span class="mw-headline" id="Mod_frequency_high_.28.244087.29">Mod frequency high ($4087)</span></h3>
<p>Setting the high bit of this register halts the mod unit,
and allows the mod table to be written via $4088.
</p><p>Disabling the resets its timer accumulator, delaying the first tick after re-enabling.
</p>
<pre>7  bit  0  (write)
---- ----
Dxxx FFFF
|    ||||
|    ++++- Bits 8-11 of modulation frequency
+--------- Disable modulation
</pre>
<h3><span class="mw-headline" id="Mod_table_write_.28.244088.29">Mod table write ($4088)</span></h3>
<p>This register has no effect unless the mod unit is disabled via the high bit of $4087.
</p><p>The mod table is a ring buffer containing 64 entries.
Writing to this register replaces two consecutive entries starting at the current
mod table playback position with the written value, then advances the playback position
to the following entry.
</p><p>Writing to this register 32 times will effectively reset the phase of the mod table,
having advanced the playback position back to its starting point. You should normally
always write all 32 entries at once, since the starting write position is not easily
predictable.
</p>
<pre>7  bit  0  (write)
---- ----
xxxx xMMM
      |||
      +++- Modulation input
</pre>
<h3><span class="mw-headline" id="Wave_write_.2F_master_volume_.28.244089.29">Wave write / master volume ($4089)</span></h3>
<p>When the high bit is set, the current waveform output is held at
its current level until the bit is cleared again. During this time,
the wave unit will continue to run, even though the output level
is held.
</p>
<pre>7  bit  0  (write)
---- ----
Wxxx xxVV
|      ||
|      ++- Master volume (0: full; 1: 2/3; 2: 2/4; 3: 2/5)
|          Output volume = current volume (see $4080 above) * master volume
+--------- Wavetable write enable
           (0: write protect RAM; 1: write enable RAM and hold channel)
</pre>
<h3><span class="mw-headline" id="Envelope_speed_.28.24408A.29">Envelope speed ($408A)</span></h3>
<p>This sets a clock multiplier for the volume and modulator envelopes.
Few FDS NSFs write to this register. The BIOS initializes this to $FF.
</p>
<pre>7  bit  0  (write)
---- ----
SSSS SSSS
|||| ||||
++++-++++- Sets speed of volume envelope and sweep envelope
           (0: disable them)
</pre>
<h3><span class="mw-headline" id="Volume_gain_.28.244090.29">Volume gain ($4090)</span></h3>
<pre>7  bit  0  (read; write through $4080)
---- ----
OOVV VVVV
|||| ||||
||++-++++- Current volume gain level
++-------- Returns 01 on read, likely from open bus
</pre>
<h3><span class="mw-headline" id="Mod_gain_.28.244092.29">Mod gain ($4092)</span></h3>
<pre>7  bit  0  (read; write through $4084)
---- ----
OOVV VVVV
|||| ||||
||++-++++- Current mod gain level
++-------- Returns 01 on read, likely from open bus
</pre>
<h2><span class="mw-headline" id="Frequency_calculation_and_timing">Frequency calculation and timing</span></h2>
<h3><span class="mw-headline" id="Envelopes">Envelopes</span></h3>
<p>The volume and modulator envelopes tick once after a specific number of CPU clocks,
calculated in the following way:
</p>
<pre>c = CPU clocks per tick
e = envelope speed ($4080/4084)
m = master envelope speed ($408A)

c =  8 * (e + 1) * m
</pre>
<p>To determine the frequency:
</p>
<pre>f = frequency of tick
n = CPU clock rate (≈1789773 Hz)

f = n / c
</pre>
<p>Writing the envelope control registers for these units will reset the timer for the respective unit,
meaning that it will next tick <b>c</b> cycles after the write.
</p>
<h3><span class="mw-headline" id="Wavetables">Wavetables</span></h3>
<p>The wave output and modulator accumulate a 16-bit phase value by adding the
current 12-bit pitch value ($4082/$4083 or $4086/$4087) once per CPU clock.
When the accumulator overflows, the table output position will advance by one.
</p>
<pre>f = frequency of tick
n = CPU clock rate (≈1789773 Hz)
p = current pitch value ($4082/$4083 or $4086/$4087) plus modulation if wave output
</pre>
<pre>f = n * p / 65536
</pre>
<p>Note that to determine the frequency of the entire waveform, divide this result by 64 (the length of the wavetable).
</p><p>The pitch value for the wave output not simply the 12-bit value from registers $4082/$4083, but is
modified by the modulator counter in an obtuse way. See below for details.
</p><p>Disabling either unit via the high bit of $4083/$4087 immediately resets the accumulator,
delaying the next tick after they are enabled again until the next overflow.
For the wave output, disabling the unit also resets the wave position to 0 (i.e. the $4040 value).
</p>
<h2><span class="mw-headline" id="Unit_tick">Unit tick</span></h2>
<h3><span class="mw-headline" id="Envelopes_2">Envelopes</span></h3>
<p>If enabled, when the volume or mod table envelope is ticked by its timer,
it will do one of the following based on $4080/$4084 bit 6:
</p>
<ul><li>Increase: if gain is less than 32, increase it by 1</li>
<li>Decrease: if gain is more than 0, decrease it by 1</li></ul>
<p>Note that the gains manually can be set higher than 32, but they can no longer be increased at this point.
The gain can still be decreased if above 32.
</p><p>The volume gain's final output will always be clamped to 32, even though the internal gain can be higher.
Otherwise, the volume and mod envelops are functionally identical.
</p>
<h3><span class="mw-headline" id="Modulation_unit">Modulation unit</span></h3>
<p>When the modulation unit is ticked, it applies the modulation value at the current position to the mod counter, then advances to the next position. Note that because values are written to the table in pairs, the same value will always be written twice on consecutive ticks.
</p><p>Each 3-bit value in the mod table corresponds to one of the following adjustment of the mod counter when ticked:
</p>
<pre>0 = %000 --&gt;  0
1 = %001 --&gt; +1
2 = %010 --&gt; +2
3 = %011 --&gt; +4
4 = %100 --&gt; reset to 0
5 = %101 --&gt; -4
6 = %110 --&gt; -2
7 = %111 --&gt; -1
</pre>
<p>The mod counter is a signed 7-bit value, and will wrap if overflowed, i.e. 63 + 1 = -64 after wrap, and -64 - 1 = 63.
</p><p>The value of the mod counter will modify the pitch of the wave output unit in a complicated way,
described by the following C-style code:
</p>
<pre>// pitch   = $4082/4083 (12-bit unsigned pitch value)
// counter = $4085 (7-bit signed mod counter)
// gain    = $4084 (6-bit unsigned mod gain)

// 1. multiply counter by gain, lose lowest 4 bits of result but &quot;round&quot; in a strange way
temp = counter * gain;
remainder = temp &amp; 0xF;
temp &gt;&gt;= 4;
if ((remainder &gt; 0) &amp;&amp; ((temp &amp; 0x80) == 0))
{
    if (counter &lt; 0) temp -= 1;
    else temp += 2;
}

// 2. wrap if a certain range is exceeded
if (temp &gt;= 192) temp -= 256;
else if (temp &lt; -64) temp += 256;

// 3. multiply result by pitch, then round to nearest while dropping 6 bits
temp = pitch * temp;
remainder = temp &amp; 0x3F;
temp &gt;&gt;= 6;
if (remainder &gt;= 32) temp += 1;

// final mod result is in temp
wave_pitch = pitch + temp;
</pre>
<p>Note that the resulting pitch value can go higher than 4095 (it will not wrap to 12-bits),
and if it goes lower than 0 it is presumably clamped to 0 (again, will not wrap).
</p>
<h3><span class="mw-headline" id="Wave_output_unit">Wave output unit</span></h3>
<p>When this unit is ticked, it advances to the next position in its wave table.
</p>
<h2><span class="mw-headline" id="Mixing">Mixing</span></h2>
<p>The current wave output value is attenuated by the current volume gain and master volume. This output signal is affected by a filter that attenuates higher frequencies. This filter can be approximated as a 1-pole lowpass with a cutoff of ~2000Hz.
</p><p>The maximum volume of the FDS signal on a Famicom is roughly 2.4x the maximum volume of the APU square, and the polarity is the same as the 2A03. On other machines, such as the Twin Famicom, the output may be significantly louder.
</p><p>The DAC output of the waveform is 6-bits (0-63), and ideally should be linear, but recent tests have revealed jagged discontinuities at binary nodes. (More works needs to be done to measure this effect.)
</p><p>The volume is applied by a pulse width modulation, but because this modulation is above the audible threshold it may be emulated simply as a linear volume control.
</p>
<h2><span class="mw-headline" id="References">References</span></h2>
<ul><li><a class="external text" href="http://forums.nesdev.com/viewtopic.php?f=3&amp;t=10233" rel="nofollow">FDS output notes</a> (from forums)</li>
<li><a class="external text" href="http://nesdev.com/FDS.txt" rel="nofollow">FDS Sound</a> by Disch</li>
<li><a class="external text" href="http://nesdev.com/FDS%20technical%20reference.txt" rel="nofollow">Famicom Disk System technical reference</a> by Brad Taylor</li>
<li><a class="external text" href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PALL&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.htm&amp;r=1&amp;f=G&amp;l=50&amp;s1=4,783,812.PN.&amp;OS=PN/4,783,812&amp;RS=PN/4,783,812" rel="nofollow">US Patent 4783812 on the FDS sound system</a></li></ul>

<!-- 
NewPP limit report
CPU time usage: 0.086 seconds
Real time usage: 0.089 seconds
Preprocessor visited node count: 95/1000000
Preprocessor generated node count: 100/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key nesdev_wiki-mw1_:pcache:idhash:105-1!*!0!!en!*!* and timestamp 20160208224928 and revision id 9561
 -->
<p class="categories">Categories: <a href="Category_Expansion_audio.xhtml">Expansion audio</a></p></div></body></html>